#!KAMAILIO
#
# VSS OMNI TELECOM - Kamailio SIP Registrar and Proxy Configuration
# Полная конфигурация для работы со слотами и Asterisk
#

####### Global Parameters #########

# Debug level (0-4)
debug=3

# Logging
log_stderror=no
log_facility=LOG_LOCAL0

# Process management
fork=yes
children=4

# Network interfaces
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Domain
alias=vss.internal

####### Modules Section ########

# *** value defines the order of the modules
loadmodule "tm"
loadmodule "sl"
loadmodule "rr"
loadmodule "pv"
loadmodule "maxfwd"
loadmodule "usrloc"
loadmodule "registrar"
loadmodule "textops"
loadmodule "siputils"
loadmodule "xlog"
loadmodule "sanity"
loadmodule "ctl"
loadmodule "cfg_rpc"
loadmodule "acc"
loadmodule "auth"
loadmodule "auth_db"
loadmodule "nathelper"
loadmodule "rtpproxy"
loadmodule "dispatcher"
loadmodule "permissions"
loadmodule "dialog"
loadmodule "statistics"

####### Module Parameters #########

# ----- tm params -----
modparam("tm", "fr_timer", 30)
modparam("tm", "fr_inv_timer", 30)
modparam("tm", "wt_timer", 10)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")
modparam("usrloc", "timer_interval", 10)
modparam("usrloc", "expire_time", 3600)
modparam("usrloc", "db_ops_ruid", 1)

# ----- auth_db params -----
modparam("auth_db", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)

# ----- registrar params -----
modparam("registrar", "default_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "max_expires", 7200)
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
modparam("registrar", "tcp_persistent_timeout", 60)

# ----- acc params -----
modparam("acc", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")
modparam("acc", "log_flag", 1)
modparam("acc", "log_missed_flag", 1)
modparam("acc", "log_extra", "src_user=$fU;src_domain=$fd;dst_user=$tU;dst_domain=$td")
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "report_cancels", 1)

# ----- dispatcher params -----
modparam("dispatcher", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_probing_threshold", 1)

# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")
modparam("rtpproxy", "rtpproxy_disable_tout", 0)
modparam("rtpproxy", "rtpproxy_tout", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", "NAT_PING")
modparam("nathelper", "sipping_from", "sip:pinger@vss.internal")

# ----- permissions params -----
modparam("permissions", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")

# ----- dialog params -----
modparam("dialog", "db_url", "postgresql://vss:vss_postgres_pass@postgres:5432/vss_db")
modparam("dialog", "db_mode", 2)
modparam("dialog", "default_timeout", 21600)
modparam("dialog", "enable_stats", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- xlog params -----
modparam("xlog", "log_level", 3)

####### Routing Logic ########

# Main request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);

    # Handle requests within SIP dialogs
    if (has_totag()) {
        route(WITHINDLG);
    }

    # Handle REGISTER requests
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Handle INVITE requests
    if (is_method("INVITE")) {
        route(FROM_SLOTS);
        exit;
    }

    # Handle other requests
    route(TO_ASTERISK);
    exit;
}

# Initial sanity checks
route[REQINIT] {
    # Max-Forwards header check
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Sanity checks
    if (!sanity_check(1511, 7)) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Record routing for stateful processing
    if (!is_method("REGISTER|MESSAGE"))
        record_route();

    # NAT detection and handling
    if (nat_uac_test(19)) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            fix_nated_contact();
        }
        setflag(NAT_PING);
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (loose_route()) {
        route(TO_ASTERISK);
        exit;
    } else {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                t_reply("200", "OK");
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply(404, "Not here");
        exit;
    }
}

# REGISTER requests - Register slots
route[REGISTRAR] {
    # Check if authorization header is present
    if (!is_present_hf("Authorization")) {
        challenge("$fd", "0");
        exit;
    }

    # Authenticate
    if (!www_authorize("vss.internal", "subscriber")) {
        www_challenge("vss.internal", "0");
        exit;
    }

    # Check To header
    if (!check_to()) {
        sl_reply("401", "Unauthorized");
        exit;
    }

    # Save location
    if (!save("location")) {
        sl_reply_error();
        exit;
    }

    # Log registration
    xlog("L_INFO", "Slot registered: $tu from $si:$sp (Contact: $ct)\n");
    
    # Accounting
    acc_db_request("register", "location");
    
    exit;
}

# Route calls from slots
route[FROM_SLOTS] {
    # Check if internal call (6xxx, 7xxx, 8xxx)
    if ($rU =~ "^[6-8][0-9]{3}$") {
        xlog("L_INFO", "Internal call: $rU from $fu to $tu\n");
        
        # Internal call - lookup location
        if (!lookup("location")) {
            sl_send_reply(404, "User Not Found");
            exit;
        }

        # NAT handling
        if (isflagset(NAT_PING)) {
            rtpproxy_manage("co");
        }

        # Route to registered slot
        t_on_reply("MANAGE_REPLY");
        t_on_failure("MANAGE_FAILURE");
        route(RELAY);
        exit;
    }

    # External call - route to Asterisk
    xlog("L_INFO", "External call: $rU from $fu, routing to Asterisk\n");
    route(TO_ASTERISK);
    exit;
}

# Route to Asterisk
route[TO_ASTERISK] {
    # Set destination URI
    $du = "sip:asterisk:5060";
    
    # NAT handling
    if (isflagset(NAT_PING)) {
        rtpproxy_manage("co");
    }
    
    # Relay
    route(RELAY);
    exit;
}

# Relay request
route[RELAY] {
    # Start transaction
    if (!t_relay()) {
        sl_reply_error();
    }
    
    # Accounting
    acc_db_request("call", "location");
    
    exit;
}

# Manage SIP replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "Reply received: $rs $rr from $si:$sp\n");
    
    # NAT handling
    if (isflagset(NAT_PING)) {
        rtpproxy_manage("co");
    }
    
    exit;
}

# Manage failures
failure_route[MANAGE_FAILURE] {
    xlog("L_WARN", "Request failed: $T_reply_code $T_reply_reason\n");
    
    # Handle specific failure codes
    if (t_check_status("408|504")) {
        xlog("L_WARN", "Timeout for call to $rU\n");
    } else if (t_check_status("404|486|600")) {
        xlog("L_WARN", "User unavailable: $rU\n");
    }
    
    exit;
}

# Local request routing
local_route {
    # Handle local requests
    if (is_method("BYE")) {
        acc_db_request("call", "location");
    }
    
    exit;
}
